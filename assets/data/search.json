[
  
  {
    "title"    : "Cell Compete",
    "category" : "",
    "tags"     : " C++, implementation",
    "url"      : "/algoguru/2019/12/23/cell_compete.html",
    "date"     : "December 23, 2019",
    "excerpt"  : "Source\n\n    vector&amp;lt;int&amp;gt; cellCompete(int* states, int days){\n        \n         FOR(i, NUM_HOUSES){\n            m_dualStates[0][i] = states[i];\n        }\n\n        FOR(d, days){\n            const int i = d%2;\n            const int ni = (d+1)%2;...",
  "content"  : "Source\n\n    vector&amp;lt;int&amp;gt; cellCompete(int* states, int days){\n        \n         FOR(i, NUM_HOUSES){\n            m_dualStates[0][i] = states[i];\n        }\n\n        FOR(d, days){\n            const int i = d%2;\n            const int ni = (d+1)%2;\n            FOR(h, NUM_HOUSES){\n                if(h == 0){\n                    if(m_dualStates[i][h+1] == 0){\n                        m_dualStates[ni][h] = 0;\n                    }\n                    else{\n                        m_dualStates[ni][h] = 1;\n                    }\n                }\n                else if(h == (NUM_HOUSES-1)){\n                    if(m_dualStates[i][h-1] == 0){\n                        m_dualStates[ni][h] = 0;\n                    }\n                    else{\n                        m_dualStates[ni][h] = 1;\n                    }\n                }\n                else{\n                    if(m_dualStates[i][h-1] == m_dualStates[i][h+1]){\n                        m_dualStates[ni][h] = 0;\n                    }\n                    else{\n                        m_dualStates[ni][h] = 1;\n                    }\n                }\n            }\n        }\n        const int resIdx = days%2;\n        return m_dualStates[resIdx];\n    }\n};\n\nGitHub\n\nCellCompete\n\n\n"
} ,
  
  {
    "title"    : "Atom Decaying",
    "category" : "",
    "tags"     : " C++, implementation, sort, unique and erase vector, STL::stack, STL::priority_queue",
    "url"      : "/algoguru/2019/08/14/atom-decaying.html",
    "date"     : "August 14, 2019",
    "excerpt"  : "Source\n\n\texplicit CProbSolve(const int N) {\n\t\tm_numAtomsN = N;\n\t\tFOR(i, eDIR_LEN){\n\t\t\tvi viEmpty;\n\t\t\tm_vviAtomIdx.push_back(viEmpty);\n\t\t}\n\t\tFOR(atIdx, m_numAtomsN) {\n\t\t\tint x, y, dir, enrg;\n\t\t\tcin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; dir &amp;gt;&amp;gt; enrg;\n...",
  "content"  : "Source\n\n\texplicit CProbSolve(const int N) {\n\t\tm_numAtomsN = N;\n\t\tFOR(i, eDIR_LEN){\n\t\t\tvi viEmpty;\n\t\t\tm_vviAtomIdx.push_back(viEmpty);\n\t\t}\n\t\tFOR(atIdx, m_numAtomsN) {\n\t\t\tint x, y, dir, enrg;\n\t\t\tcin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; dir &amp;gt;&amp;gt; enrg;\n\t\t\tm_vAtoms.push_back(Atom(x, y, dir, enrg));\n\t\t\tm_vviAtomIdx[dir].push_back(atIdx);\n\t\t}\n\t\t_Solve();\n\t}\n\n\tvoid _Solve() {\n\t\t// Find orthogonal crashes of earlier time than the times of relative atoms\n\t\t_FindOrthoCrash();\n\t\t_FindLinearCrash();\n\n\t\t// Sum up the energy of atoms with the limited time\n\t\tconst int energySum = _SumUpEnergy();\n\t\tcout &amp;lt;&amp;lt; energySum &amp;lt;&amp;lt; &quot;\\n&quot;;\n\t}\n\n\tvoid _FindOrthoCrash()\n\t{\n\t\tfor(int atI : m_vviAtomIdx[eD]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eR]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int xVector = at1.x - at2.x;\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (xVector == yVector) {\n\t\t\t\t\tconst int dbldTime = 2 * xVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int atI : m_vviAtomIdx[eL]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eU]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int xVector = at1.x - at2.x;\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (xVector == yVector) {\n\t\t\t\t\tconst int dbldTime = 2 * xVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int atI : m_vviAtomIdx[eD]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eL]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int xVector = at2.x - at1.x;\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (xVector == yVector) {\n\t\t\t\t\tconst int dbldTime = 2 * xVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int atI : m_vviAtomIdx[eR]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eU]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int xVector = at2.x - at1.x;\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (xVector == yVector) {\n\t\t\t\t\tconst int dbldTime = 2 * xVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tvoid _FindLinearCrash()\n\t{\n\t\tfor(int atI : m_vviAtomIdx[eD]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eU]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int xVector = at1.x - at2.x;\n\t\t\t\tif (xVector != 0) continue;\n\t\t\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (yVector &amp;gt; 0) {\n\t\t\t\t\tconst int dbldTime = yVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int atI : m_vviAtomIdx[eL]) {\n\t\t\tfor(int atJ : m_vviAtomIdx[eR]) {\n\t\t\t\tconst Atom_t &amp;amp;at1 = m_vAtoms[atI];\n\t\t\t\tconst Atom_t &amp;amp;at2 = m_vAtoms[atJ];\n\t\t\t\tconst int yVector = at1.y - at2.y;\n\t\t\t\tif (yVector != 0) continue;\n\n\t\t\t\tconst int xVector = at1.x - at2.x;\n\t\t\t\tif (xVector &amp;gt; 0) {\n\t\t\t\t\tconst int dbldTime = xVector;\n\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(atI, atJ)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint _SumUpEnergy() {\n\t\tint enrgSum = 0;\n\t\tsort(m_vCrashes.begin(), m_vCrashes.end());\n\t\tm_vCrashes.erase(unique(m_vCrashes.begin(), m_vCrashes.end()), m_vCrashes.end());\n\t\tconst int numCrashes = (int)m_vCrashes.size();\n\t\tFOR(crIdx, numCrashes) {\n\t\t\tconst Crash dbldTime_at1at2 = m_vCrashes[crIdx];\n\t\t\tAtom_t &amp;amp;atm1 = m_vAtoms[dbldTime_at1at2.second.first];\n\t\t\tAtom_t &amp;amp;atm2 = m_vAtoms[dbldTime_at1at2.second.second];\n\t\t\tconst int dbldTime = dbldTime_at1at2.first;\n\t\t\tif ((atm1.enrg &amp;lt; 0) &amp;amp;&amp;amp; (atm1.enrg != -dbldTime)) continue;\n\t\t\tif ((atm2.enrg &amp;lt; 0) &amp;amp;&amp;amp; (atm2.enrg != -dbldTime)) continue;\n\t\t\tif (atm1.enrg &amp;gt; 0) {\n\t\t\t\tenrgSum += atm1.enrg;\n\t\t\t\tatm1.enrg = -dbldTime;\n\t\t\t}\n\t\t\tif (atm2.enrg &amp;gt; 0) {\n\t\t\t\tenrgSum += atm2.enrg;\n\t\t\t\tatm2.enrg = -dbldTime;\n\t\t\t}\n\t\t}\n\t\treturn enrgSum;\n\t}\n\n#ifdef PQII\n\tvoid _FindLinearCrash(pqii &amp;amp; pqiiSortedList)\n\t{\n\t\tstack&amp;lt;ii&amp;gt; atmS;\n\t\twhile (!pqiiSortedList.empty()) {\n\t\t\tconst ii XorY_atIdx = pqiiSortedList.top(); pqiiSortedList.pop();\n\t\t\tconst Atom_t atm = m_vAtoms[XorY_atIdx.second];\n\t\t\tif (!atmS.empty()) {\n\t\t\t\tconst ii prev_XorY_atIdx = atmS.top();\n\t\t\t\t// filter out duplicate atom index\n\t\t\t\tif (XorY_atIdx.second == prev_XorY_atIdx.second) continue;\n\t\t\t\tconst Atom_t prev_atm = m_vAtoms[prev_XorY_atIdx.second];\n\t\t\t\tconst int dbldTime = prev_XorY_atIdx.first - XorY_atIdx.first;\n\t\t\t\tif ((prev_atm.dir == eD) || (prev_atm.dir == eL)) {\n\t\t\t\t\tif ((atm.dir == eU) || (atm.dir == eR)) {\n\t\t\t\t\t\tconst int smallerIdx = min(XorY_atIdx.second, prev_XorY_atIdx.second);\n\t\t\t\t\t\tconst int biggerIdx = max(XorY_atIdx.second, prev_XorY_atIdx.second);\n\t\t\t\t\t\tm_vCrashes.push_back(Crash(dbldTime, ii(smallerIdx, biggerIdx)));\n\t\t\t\t\t\tatmS.pop();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tatmS.push(XorY_atIdx);\n\t\t}\n\t}\n#endif // PQII\n\nGitHub\n\nAtomDecaying\n\n\n"
} ,
  
  {
    "title"    : "Stem Cell Culture",
    "category" : "",
    "tags"     : " C++, implementation, BFS with generations, STL::queue",
    "url"      : "/algoguru/2019/07/18/StemCellCulture.html",
    "date"     : "July 18, 2019",
    "excerpt"  : "Source\n\n\texplicit CProbSolve(const int N, const int M, const int K) {\n\t\t(void)memset(&amp;amp;(g_arMap[0][0]), 0, sizeof(g_arMap));\n\t\tm_initRowsN = N;\n\t\tm_initColsM = M;\n\t\tm_timeLimitK = K;\n\t\tm_mapMaxRows = INIT_MAP_OFFSET + m_initRowsN + INIT_MAP_OFF...",
  "content"  : "Source\n\n\texplicit CProbSolve(const int N, const int M, const int K) {\n\t\t(void)memset(&amp;amp;(g_arMap[0][0]), 0, sizeof(g_arMap));\n\t\tm_initRowsN = N;\n\t\tm_initColsM = M;\n\t\tm_timeLimitK = K;\n\t\tm_mapMaxRows = INIT_MAP_OFFSET + m_initRowsN + INIT_MAP_OFFSET;\n\t\tm_mapMaxCols = INIT_MAP_OFFSET + m_initColsM + INIT_MAP_OFFSET;\n\t\tm_mapRowRange.first = m_mapMaxRows;\n\t\tm_mapRowRange.second = 0;\n\t\tm_mapColRange.first = m_mapMaxCols;\n\t\tm_mapColRange.second = 0;\n\t\tFOR(row, m_initRowsN) {\n\t\t\tFOR(col, m_initColsM) {\n\t\t\t\tint val = 0;\n\t\t\t\tcin &amp;gt;&amp;gt; val;\n\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\tg_arMap[0][row + INIT_MAP_OFFSET][col + INIT_MAP_OFFSET] = val;\n\t\t\t\t\tg_arMap[1][row + INIT_MAP_OFFSET][col + INIT_MAP_OFFSET] = val;\n\t\t\t\t\t_UpdateRange(row + INIT_MAP_OFFSET, col + INIT_MAP_OFFSET);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_Solve();\n\t}\n\n\tvoid _BFSwithGenerations() {\n\t\tqueue&amp;lt;i_ii&amp;gt; arqLifePos[2];\n\n\t\tFOR_INC(row, m_mapRowRange.first, m_mapRowRange.second + 1) {\n\t\t\tFOR_INC(col, m_mapColRange.first, m_mapColRange.second + 1) {\n\t\t\t\tconst int val = g_arMap[0][row][col];\n\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\tarqLifePos[0].push(i_ii(2 * val, (ii(row, col))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// repeat the loop until time limit\n\t\tvector&amp;lt;i_ii&amp;gt; vPrevExtendedCells;\n\t\tFOR(gen, m_timeLimitK) {\n\t\t\tconst int i = gen % 2;\n\t\t\tconst int ni = (gen + 1) % 2;\n\n\t\t\tif (!vPrevExtendedCells.empty()) {\n\t\t\t\t// update the map and the queue with previously extended cells\n\t\t\t\t_UpdateMapAndQueue(vPrevExtendedCells, arqLifePos[i]);\n\t\t\t}\n\n\t\t\t// visit all the stem cells in the current queue\n\t\t\twhile (!arqLifePos[i].empty()) {\n\t\t\t\tconst i_ii life_pos = arqLifePos[i].front(); arqLifePos[i].pop();\n\t\t\t\tconst int row = life_pos.second.first;\n\t\t\t\tconst int col = life_pos.second.second;\n\n\t\t\t\t// getting old\n\t\t\t\tconst int life = life_pos.first - 1;\n\t\t\t\tif (life &amp;lt;= 0) {\n\t\t\t\t\t// dies\n\t\t\t\t\tg_arMap[0][row][col] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// still alive: push into the next queue\n\t\t\t\tarqLifePos[ni].push(i_ii(life, ii(row, col)));\n\t\t\t\tconst int val = g_arMap[0][row][col];\n\t\t\t\tif (life &amp;gt; val) continue;\n\n\t\t\t\t// now active!\n\t\t\t\t// for extention, the map is going to be updated in the next loop\n\t\t\t\tFOR(dir, eDIR_LEN) {\n\t\t\t\t\tconst int nextRow = row + DIR[dir][0];\n\t\t\t\t\tconst int nextCol = col + DIR[dir][1];\n\t\t\t\t\tP_IFNOT(!OOR(nextRow, 0, m_mapMaxRows - 1), nextRow);\n\t\t\t\t\tP_IFNOT(!OOR(nextCol, 0, m_mapMaxCols - 1), nextCol);\n\t\t\t\t\tif (g_arMap[0][nextRow][nextCol] != 0) continue;\n\n\t\t\t\t\t// previously empty cell\n\t\t\t\t\tif (val &amp;gt; g_arMap[1][nextRow][nextCol]) {\n\t\t\t\t\t\tg_arMap[1][nextRow][nextCol] = val;\n\t\t\t\t\t\t_UpdateRange(nextRow, nextCol);\n\n\t\t\t\t\t\t// extention candidates which will get old from the next after the next generation\n\t\t\t\t\t\tvPrevExtendedCells.push_back(i_ii((2 * val) + 1, ii(nextRow, nextCol)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t// while (!m_arqLifePos[i].empty())\n\n\t\t} // FOR(gen, m_timeLimitK)\n\t}\n\n\tvoid _UpdateMapAndQueue(vector&amp;lt;i_ii&amp;gt; &amp;amp;vPrevExtendedCellsOut, queue&amp;lt;i_ii&amp;gt; &amp;amp;qLifePosOut)\n\t{\n\t\twhile (!vPrevExtendedCellsOut.empty()) {\n\t\t\tconst i_ii life_pos = vPrevExtendedCellsOut.back(); vPrevExtendedCellsOut.pop_back();\n\t\t\tconst int row = life_pos.second.first;\n\t\t\tconst int col = life_pos.second.second;\n\t\t\tconst int val = g_arMap[1][row][col];\n\t\t\tif (life_pos.first == (2 * val) + 1) {\n\t\t\t\t// resultant extentions\n\t\t\t\tg_arMap[0][row][col] = val;\n\n\t\t\t\t// it start to get old from the next generation\n\t\t\t\tqLifePosOut.push(life_pos);\n\t\t\t}\n\t\t}\n\t}\n\nSource with respective queues for each life time\n\n#pragma GCC optimize(&quot;O3&quot;)\n#include &amp;lt;iostream&amp;gt;\n#include &amp;lt;algorithm&amp;gt;\n#include &amp;lt;memory.h&amp;gt;\nusing namespace std;\n \n#define BASE 151\n \nstruct p {\n    int r, x, y;\n};\n \nint map[360][360];\np q[11][2][2001];\t// life time, switching by 2, cell of each life time\n \nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    register int t, tc, N, M, K, s, dx[] = { 0,0,1,-1 }, dy[] = { 1,-1,0,0 }, idx[11][2] = { 0, };\n     \n    cin &amp;gt;&amp;gt; t;\n    for (tc = 1; tc &amp;lt;= t; ++tc) {\n        register int i, j, k, l, nx, ny, ans, siz, ni, tt;\n        memset(map, 0, sizeof(map));\n        memset(idx, 0, sizeof(idx));\n        cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M &amp;gt;&amp;gt; K;\n        ans = 0;\n        for (i = 0; i &amp;lt; N; ++i) for (j = 0; j &amp;lt; M; ++j) {\n            nx = i + BASE; ny = j + BASE;\n            cin &amp;gt;&amp;gt; tt;\n            if (tt) \n                q[tt][0][idx[tt][0]++] = { 2 * tt, nx, ny };\n            map[nx][ny] = tt;\n        }\n        s = 0;\n\t\t// for generations\n        for (i = 0; i &amp;lt;= K; ++i) {\n\t\t\t// for each life time\n            for (j = 10; j &amp;gt;= 1; --j) {\n                siz = idx[j][i % 2];\n                ni = (i + 1) % 2;\n                idx[j][ni] = 0;\n\n\t\t\t\t// for each cell of each life time\n                for (k = 0; k &amp;lt; siz; ++k) {\n                    p &amp;amp;x = q[j][i%2][k];\n                    if (x.r &amp;gt; j) {\n                        if (map[x.x][x.y] &amp;gt; 0) {\n                            ans++;\n                            map[x.x][x.y] *= -1;\n                        }\n                        q[j][ni][idx[j][ni]++] = { x.r - 1,x.x,x.y };\n                    }\n                    else if (x.r == j) {\n                        q[j][ni][idx[j][ni]++] = { x.r - 1,x.x,x.y };\n                        for (l = 0; l &amp;lt; 4; ++l) {\n                            nx = x.x + dx[l];\n                            ny = x.y + dy[l];\n                            if (map[nx][ny]) continue;\n                            map[nx][ny] = j;\n                            q[j][ni][idx[j][ni]++] = { 2 * j,nx,ny };\n                        }\n                    }\n                    else if (j &amp;gt; x.r &amp;amp;&amp;amp; x.r) \n                        q[j][ni][idx[j][ni]++] = { x.r - 1,x.x,x.y };\n                    else\n                        ans--;\n                }\n            }\n        }\n        cout &amp;lt;&amp;lt; &#39;#&#39; &amp;lt;&amp;lt; tc &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &#39;\\n&#39;;\n    }\n    return 0;\n}\n\nGitHub\n\nStemCellCulture\n\n\n"
} ,
  
  {
    "title"    : "Road Construction",
    "category" : "",
    "tags"     : " C++, Dijkstra, STL::priority_queue",
    "url"      : "/algoguru/2019/07/18/RoadConstruction.html",
    "date"     : "July 18, 2019",
    "excerpt"  : "Source\n\n\texplicit CProbSolve(const int N) {\n\t\tm_mapSizeN = N;\n\t\tm_minCost = INF;\n\t\tFOR(row, m_mapSizeN) {\n\t\t\tvii viiRow;\n\t\t\tint cnt = 0;\n\t\t\twhile (cnt &amp;lt; m_mapSizeN) {\n\t\t\t\tconst char cVal = cin.get();\n\t\t\t\tconst int val = cVal - &#39;0&#39;;\n\t\t\t\tif (val ...",
  "content"  : "Source\n\n\texplicit CProbSolve(const int N) {\n\t\tm_mapSizeN = N;\n\t\tm_minCost = INF;\n\t\tFOR(row, m_mapSizeN) {\n\t\t\tvii viiRow;\n\t\t\tint cnt = 0;\n\t\t\twhile (cnt &amp;lt; m_mapSizeN) {\n\t\t\t\tconst char cVal = cin.get();\n\t\t\t\tconst int val = cVal - &#39;0&#39;;\n\t\t\t\tif (val &amp;gt;= 0 &amp;amp;&amp;amp; val &amp;lt;= 9) {\n\t\t\t\t\tviiRow.push_back(ii(INF, val));\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_map.push_back(viiRow);\n\t\t}\n\t\t_Solve();\n\t}\n\n\tvoid _Dijkstra(const ii start, const ii finish) {\n\t\tm_pqiiPos.push(i_ii(-m_map[start.first][start.second].second, start));\n\t\twhile (!m_pqiiPos.empty()) {\n\t\t\tconst i_ii cost_pos = m_pqiiPos.top(); m_pqiiPos.pop();\n\t\t\tconst int cost = -cost_pos.first;\n\t\t\tconst int row = cost_pos.second.first;\n\t\t\tconst int col = cost_pos.second.second;\n\n\t\t\t// Check if it&#39;s deprecated cost\n\t\t\tif (cost &amp;gt; m_map[row][col].first) continue;\n\n\t\t\tFOR(dir, eDIR_LEN) {\n\t\t\t\tconst int nextRow = row + DIR[dir][0];\n\t\t\t\tconst int nextCol = col + DIR[dir][1];\n\t\t\t\tif (OOR(nextRow, 0, m_mapSizeN - 1)) continue;\n\t\t\t\tif (OOR(nextCol, 0, m_mapSizeN - 1)) continue;\n\t\t\t\tconst int nextCost = cost + m_map[nextRow][nextCol].second;\n\n\t\t\t\t// Check if it&#39;s smaller cost\n\t\t\t\tif (nextCost &amp;gt;= m_map[nextRow][nextCol].first) continue;\n\n\t\t\t\t// Visit\n\t\t\t\tm_map[nextRow][nextCol].first = nextCost;\n#if 1\n\t\t\t\t// Check if it reaches the finish point\n\t\t\t\tif ((nextRow == finish.first) &amp;amp;&amp;amp; (nextCol == finish.second)) {\n\t\t\t\t\tm_minCost = nextCost;\n\t\t\t\t\treturn;\n\t\t\t\t}\n#endif // 1\n\t\t\t\t// Add next cell to start from\n\t\t\t\tm_pqiiPos.push(i_ii(-nextCost, ii(nextRow, nextCol)));\n\t\t\t}\n\t\t}\n\n\t\tm_minCost = m_map[finish.first][finish.second].first;\n\t}\n\nGitHub\n\nRoadConstruction\n\n\n"
} ,
  
  {
    "title"    : "Game 2048",
    "category" : "",
    "tags"     : " C++, implementation, DFS with backtracking",
    "url"      : "/algoguru/2019/07/17/Game-Two-Zero-Four-Eight.html",
    "date"     : "July 17, 2019",
    "excerpt"  : "Source\n\n\tvoid _DFS(const vvi &amp;amp;map, const int numMoves, const Dir_e dir) {\n\t\tvvi movedMap(map);\n#if 1\n        _MoveWithQ(dir, movedMap);\n#else\n        _Move(dir, movedMap);\n#endif // 0\n\n\t\tif (numMoves == MAX_MOVES)\n        {\n\t\t\tconst int bigges...",
  "content"  : "Source\n\n\tvoid _DFS(const vvi &amp;amp;map, const int numMoves, const Dir_e dir) {\n\t\tvvi movedMap(map);\n#if 1\n        _MoveWithQ(dir, movedMap);\n#else\n        _Move(dir, movedMap);\n#endif // 0\n\n\t\tif (numMoves == MAX_MOVES)\n        {\n\t\t\tconst int biggest = GetBiggest(movedMap);\n\t\t\tif (biggest &amp;gt; m_maxVal) {\n\t\t\t\tm_maxVal = biggest;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tFOR(nextDir, eDIR_LEN) {\n\t\t\t_DFS(movedMap, numMoves + 1, (Dir_e)nextDir);\n\t\t}\n\t}\n\n\tint _MoveWithQ(const Dir_e dir, vvi &amp;amp;mapOut) {\n\t\tint numMerges = 0;\n\t\tswitch (dir)\n\t\t{\n\t\tcase eR:\n\t\t\tFOR(row, m_mapSizeN) {\n\t\t\t\tqi qiVals;\n\t\t\t\tFOR_DEC(col, 0, m_mapSizeN) {\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\tqiVals.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFOR_DEC(col, 0, m_mapSizeN) {\n\t\t\t\t\t_FillCell(row, col,\n\t\t\t\t\t\t\t  mapOut, qiVals, numMerges);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eD:\n\t\t\tFOR(col, m_mapSizeN) {\n\t\t\t\tqi qiVals;\n\t\t\t\tFOR_DEC(row, 0, m_mapSizeN) {\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\tqiVals.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFOR_DEC(row, 0, m_mapSizeN) {\n\t\t\t\t\t_FillCell(row, col,\n\t\t\t\t\t\t\t  mapOut, qiVals, numMerges);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eL:\n\t\t\tFOR(row, m_mapSizeN) {\n\t\t\t\tqi qiVals;\n\t\t\t\tFOR_INC(col, 0, m_mapSizeN) {\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\tqiVals.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFOR_INC(col, 0, m_mapSizeN) {\n\t\t\t\t\t_FillCell(row, col,\n\t\t\t\t\t\t\t  mapOut, qiVals, numMerges);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eU:\n\t\t\tFOR(col, m_mapSizeN) {\n\t\t\t\tqi qiVals;\n\t\t\t\tFOR_INC(row, 0, m_mapSizeN) {\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\tqiVals.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFOR_INC(row, 0, m_mapSizeN) {\n\t\t\t\t\t_FillCell(row, col,\n\t\t\t\t\t\t\t  mapOut, qiVals, numMerges);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tP_IFNOT(dir &amp;lt; eDIR_LEN, dir);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn numMerges;\n\t}\n\n\tvoid _FillCell(const int row, const int col,\n\t\t\t\t   vvi &amp;amp;mapOut, qi &amp;amp;qiValsOut, int &amp;amp;numMergesOut) {\n\t\tint pivotVal = -1;\n\n\t\t// A. visit next\n\t\twhile (!qiValsOut.empty()) {\n\t\t\tconst int val = qiValsOut.front();\n\n\t\t\t// C. check to be merged\n\t\t\tif (val == pivotVal) {\n\t\t\t\tmapOut[row][col] = pivotVal * 2;\n\t\t\t\tpivotVal = -1;\n\t\t\t\tnumMergesOut++;\n\t\t\t\tqiValsOut.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (pivotVal != -1) {\n\t\t\t\t\tpivotVal = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// D. set pivot\n\t\t\tpivotVal = val;\n\t\t\tmapOut[row][col] = pivotVal;\n\t\t\tqiValsOut.pop();\n\t\t}\n\t}\n\n\tint _Move(const Dir_e dir, vvi &amp;amp;mapOut) {\n\t\tint numMerges = 0;\n\t\tswitch (dir)\n\t\t{\n\t\tcase eR:\n\t\t\tFOR(row, m_mapSizeN) {\n\t\t\t\tint pivotVal = 0;\n\t\t\t\tint pivotCol = 0;\n\t\t\t\tint emptyCellCol = 0;\n\t\t\t\tFOR_DEC(col, 0, m_mapSizeN) {\n\t\t\t\t\t// A. visit next\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tif (pivotVal != 0) {\n\t\t\t\t\t\t\t// C. check to be merged\n\t\t\t\t\t\t\tif (pivotVal == val) {\n\t\t\t\t\t\t\t\tmapOut[row][pivotCol] = pivotVal * 2;\n\t\t\t\t\t\t\t\tpivotVal = 0;\n\t\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\t\t\tnumMerges++;\n\n\t\t\t\t\t\t\t\t// G. set empty cell\n\t\t\t\t\t\t\t\tif (emptyCellCol == 0) {\n\t\t\t\t\t\t\t\t\temptyCellCol = col;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// D. set pivot\n\t\t\t\t\t\tpivotVal = val;\n\t\t\t\t\t\tif (emptyCellCol &amp;gt; 0) {\n\t\t\t\t\t\t\tpivotCol = emptyCellCol;\n\n\t\t\t\t\t\t\t// E. move pivot value into empty cell\n\t\t\t\t\t\t\tmapOut[row][emptyCellCol] = pivotVal;\n\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\n\t\t\t\t\t\t\t// F. set next empty cell\n\t\t\t\t\t\t\tif (emptyCellCol &amp;gt; col) {\n\t\t\t\t\t\t\t\t--emptyCellCol;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpivotCol = col;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// B. set empty cell\n\t\t\t\t\t\tif (emptyCellCol == 0) {\n\t\t\t\t\t\t\temptyCellCol = col;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eD:\n\t\t\tFOR(col, m_mapSizeN) {\n\t\t\t\tint pivotVal = 0;\n\t\t\t\tint pivotRow = 0;\n\t\t\t\tint emptyCellRow = 0;\n\t\t\t\tFOR_DEC(row, 0, m_mapSizeN) {\n\t\t\t\t\t// A. visit next\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tif (pivotVal != 0) {\n\t\t\t\t\t\t\t// C. check to be merged\n\t\t\t\t\t\t\tif (pivotVal == val) {\n\t\t\t\t\t\t\t\tmapOut[pivotRow][col] = pivotVal * 2;\n\t\t\t\t\t\t\t\tpivotVal = 0;\n\t\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\t\t\tnumMerges++;\n\n\t\t\t\t\t\t\t\t// G. set empty cell\n\t\t\t\t\t\t\t\tif (emptyCellRow == 0) {\n\t\t\t\t\t\t\t\t\temptyCellRow = row;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// D. set pivot\n\t\t\t\t\t\tpivotVal = val;\n\t\t\t\t\t\tif (emptyCellRow &amp;gt; 0) {\n\t\t\t\t\t\t\tpivotRow = emptyCellRow;\n\n\t\t\t\t\t\t\t// E. move pivot value into empty cell\n\t\t\t\t\t\t\tmapOut[emptyCellRow][col] = pivotVal;\n\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\n\t\t\t\t\t\t\t// F. set next empty cell\n\t\t\t\t\t\t\tif (emptyCellRow &amp;gt; row) {\n\t\t\t\t\t\t\t\t--emptyCellRow;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpivotRow = row;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// B. set empty cell\n\t\t\t\t\t\tif (emptyCellRow == 0) {\n\t\t\t\t\t\t\temptyCellRow = row;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eL:\n\t\t\tFOR(row, m_mapSizeN) {\n\t\t\t\tint pivotVal = 0;\n\t\t\t\tint pivotCol = 0;\n\t\t\t\tint emptyCellCol = m_mapSizeN;\n\t\t\t\tFOR_INC(col, 0, m_mapSizeN) {\n\t\t\t\t\t// A. visit next\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tif (pivotVal != 0) {\n\t\t\t\t\t\t\t// C. check to be merged\n\t\t\t\t\t\t\tif (pivotVal == val) {\n\t\t\t\t\t\t\t\tmapOut[row][pivotCol] = pivotVal * 2;\n\t\t\t\t\t\t\t\tpivotVal = 0;\n\t\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\t\t\tnumMerges++;\n\n\t\t\t\t\t\t\t\t// G. set empty cell\n\t\t\t\t\t\t\t\tif (emptyCellCol == m_mapSizeN) {\n\t\t\t\t\t\t\t\t\temptyCellCol = col;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// D. set pivot\n\t\t\t\t\t\tpivotVal = val;\n\t\t\t\t\t\tif (emptyCellCol &amp;lt; m_mapSizeN) {\n\t\t\t\t\t\t\tpivotCol = emptyCellCol;\n\n\t\t\t\t\t\t\t// E. move pivot value into empty cell\n\t\t\t\t\t\t\tmapOut[row][emptyCellCol] = pivotVal;\n\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\n\t\t\t\t\t\t\t// F. set next empty cell\n\t\t\t\t\t\t\tif (emptyCellCol &amp;lt; col) {\n\t\t\t\t\t\t\t\t++emptyCellCol;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpivotCol = col;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// B. set empty cell\n\t\t\t\t\t\tif (emptyCellCol == m_mapSizeN) {\n\t\t\t\t\t\t\temptyCellCol = col;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eU:\n\t\t\tFOR(col, m_mapSizeN) {\n\t\t\t\tint pivotVal = 0;\n\t\t\t\tint pivotRow = 0;\n\t\t\t\tint emptyCellRow = m_mapSizeN;\n\t\t\t\tFOR_INC(row, 0, m_mapSizeN) {\n\t\t\t\t\t// A. visit next\n\t\t\t\t\tconst int val = mapOut[row][col];\n\t\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\t\tif (pivotVal != 0) {\n\t\t\t\t\t\t\t// C. check to be merged\n\t\t\t\t\t\t\tif (pivotVal == val) {\n\t\t\t\t\t\t\t\tmapOut[pivotRow][col] = pivotVal * 2;\n\t\t\t\t\t\t\t\tpivotVal = 0;\n\t\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\t\t\t\t\t\t\t\tnumMerges++;\n\n\t\t\t\t\t\t\t\t// G. set empty cell\n\t\t\t\t\t\t\t\tif (emptyCellRow == m_mapSizeN) {\n\t\t\t\t\t\t\t\t\temptyCellRow = row;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// D. set pivot\n\t\t\t\t\t\tpivotVal = val;\n\t\t\t\t\t\tif (emptyCellRow &amp;lt; m_mapSizeN) {\n\t\t\t\t\t\t\tpivotRow = emptyCellRow;\n\n\t\t\t\t\t\t\t// E. move pivot value into empty cell\n\t\t\t\t\t\t\tmapOut[emptyCellRow][col] = pivotVal;\n\t\t\t\t\t\t\tmapOut[row][col] = 0;\n\n\t\t\t\t\t\t\t// F. set next empty cell\n\t\t\t\t\t\t\tif (emptyCellRow &amp;lt; row) {\n\t\t\t\t\t\t\t\t++emptyCellRow;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpivotRow = row;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// B. set empty cell\n\t\t\t\t\t\tif (emptyCellRow == m_mapSizeN) {\n\t\t\t\t\t\t\temptyCellRow = row;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tP_IFNOT(dir &amp;lt; eDIR_LEN, dir);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn numMerges;\n\t}\n\nGitHub\n\nGame2048\n\n\n"
} ,
  
  {
    "title"    : "Avoid Zeros",
    "category" : "",
    "tags"     : " C++, dynamic programing, mathematics, big number, DFS pitfall",
    "url"      : "/algoguru/2019/07/17/Avoid-Zeros.html",
    "date"     : "July 17, 2019",
    "excerpt"  : "Source\n\n\texplicit CProbSolve(const int N) {\n\t\tm_minZeros = INF;\n\t\tm_mapSizeN = N;\n\t\tP_IFNOT(m_mapSizeN &amp;gt;= 2 , m_mapSizeN);\n\t\tP_IFNOT(m_mapSizeN &amp;lt;= 1000, m_mapSizeN);\n\n\t\tFOR(row, m_mapSizeN) {\n\t\t\tvii viiRow;\n\t\t\tvi viRow;\n\t\t\tFOR(col, m_mapSize...",
  "content"  : "Source\n\n\texplicit CProbSolve(const int N) {\n\t\tm_minZeros = INF;\n\t\tm_mapSizeN = N;\n\t\tP_IFNOT(m_mapSizeN &amp;gt;= 2 , m_mapSizeN);\n\t\tP_IFNOT(m_mapSizeN &amp;lt;= 1000, m_mapSizeN);\n\n\t\tFOR(row, m_mapSizeN) {\n\t\t\tvii viiRow;\n\t\t\tvi viRow;\n\t\t\tFOR(col, m_mapSizeN) {\n\t\t\t\tint val = 0;\n\t\t\t\tcin &amp;gt;&amp;gt; val;\n\t\t\t\tP_IFNOT(val &amp;gt;= 0, val);\n\t\t\t\tint numTwos = INF;\n\t\t\t\tint numFives = INF;\n\t\t\t\tif (val &amp;gt; 0) {\n\t\t\t\t\tnumTwos = _CountFactor(2, val);\n\t\t\t\t\tnumFives = _CountFactor(5, val);\n\t\t\t\t}\n\t\t\t\tviiRow.push_back(ii(numTwos, numFives));\n\t\t\t\tviRow.push_back(val);\n\t\t\t}\n\t\t\tm_map.push_back(viiRow);\n\t\t\tm_mapCanGo.push_back(viRow);\n\t\t}\n\n\t\t_Solve();\n\t}\n\n\tint _CountFactor(const int factor, const int val) {\n\t\tint cnt = 0;\n\t\tint quotient = val;\n\t\twhile (quotient % factor == 0) {\n\t\t\tquotient /= factor;\n\t\t\tcnt++;\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid _UpdateFactorMap() {\n\t\tFOR_INC(row, 1, m_mapSizeN) {\n\t\t\tm_map[row][0].first += m_map[row - 1][0].first;\n\t\t\tif (m_map[row][0].first &amp;gt; INF) m_map[row][0].first = INF;\n\t\t\tm_map[row][0].second += m_map[row - 1][0].second;\n\t\t\tif (m_map[row][0].second &amp;gt; INF) m_map[row][0].second = INF;\n\t\t}\n\t\tFOR_INC(col, 1, m_mapSizeN) {\n\t\t\tm_map[0][col].first += m_map[0][col - 1].first;\n\t\t\tif (m_map[0][col].first &amp;gt; INF) m_map[0][col].first = INF;\n\t\t\tm_map[0][col].second += m_map[0][col - 1].second;\n\t\t\tif (m_map[0][col].second &amp;gt; INF) m_map[0][col].second = INF;\n\t\t}\n\t\tFOR_INC(row, 1, m_mapSizeN) {\n\t\t\tFOR_INC(col, 1, m_mapSizeN) {\n\t\t\t\tm_map[row][col].first += _min(m_map[row - 1][col].first, m_map[row][col - 1].first);\n\t\t\t\tif (m_map[row][col].first &amp;gt; INF) m_map[row][col].first = INF;\n\t\t\t\tm_map[row][col].second += _min(m_map[row - 1][col].second, m_map[row][col - 1].second);\n\t\t\t\tif (m_map[row][col].second &amp;gt; INF) m_map[row][col].second = INF;\n\t\t\t}\n\t\t}\n\t\tm_minZeros = _min(m_map[m_mapSizeN - 1][m_mapSizeN - 1].first, m_map[m_mapSizeN - 1][m_mapSizeN - 1].second);\n\t}\n\nGitHub\n\nAvoidZeros\n\n\n"
} ,
  
  {
    "title"    : "Naming Daughter",
    "category" : "",
    "tags"     : " C++, BFS with generations, unique and erase vector",
    "url"      : "/algoguru/2019/07/16/Naming-Daughter.html",
    "date"     : "July 16, 2019",
    "excerpt"  : "Source\n\n\tvoid _BFSWithUniqueAndSmallest(const ii &amp;amp;start) {\n\t\tm_ans = m_map[start.first][start.second];\n\t\tm_posQ.push(start);\n\t\twhile (true) {\n\t\t\twhile (!m_posQ.empty()) {\n\t\t\t\tconst ii pos = m_posQ.front(); m_posQ.pop();\n\t\t\t\tFOR(dir, eDIR_LEN) ...",
  "content"  : "Source\n\n\tvoid _BFSWithUniqueAndSmallest(const ii &amp;amp;start) {\n\t\tm_ans = m_map[start.first][start.second];\n\t\tm_posQ.push(start);\n\t\twhile (true) {\n\t\t\twhile (!m_posQ.empty()) {\n\t\t\t\tconst ii pos = m_posQ.front(); m_posQ.pop();\n\t\t\t\tFOR(dir, eDIR_LEN) {\n\t\t\t\t\tconst ii nextPos = ii(pos.first + DIR[dir][0], pos.second + DIR[dir][1]);\n\t\t\t\t\tif (OOR(nextPos.first, 0, (int)(m_rows - 1))) continue;\n\t\t\t\t\tif (OOR(nextPos.second, 0, (int)(m_cols - 1))) continue;\n#if 0 // it works sometimes\n\t\t\t\t\tconst string candName = m_ans + m_map[nextPos.first][nextPos.second];\n\t\t\t\t\tif (candName.compare(m_visit[nextPos.first][nextPos.second]) &amp;lt; 0) {\n\t\t\t\t\t\tm_visit[nextPos.first][nextPos.second] = candName;\n\t\t\t\t\t\tm_viiPos.push_back(nextPos);\n\t\t\t\t\t}\n#else\n\t\t\t\t\tm_viiPos.push_back(nextPos);\n#endif // 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_viiPos.erase(unique(m_viiPos.begin(), m_viiPos.end()), m_viiPos.end());\n\t\t\tconst int numCands = m_viiPos.size();\n\t\t\tif (numCands == 0) return;\n\n\t\t\tchar earlistC = m_map[m_viiPos[0].first][m_viiPos[0].second];\n\t\t\tFOR_INC(i, 1, numCands) {\n\t\t\t\tconst char ch = m_map[m_viiPos[i].first][m_viiPos[i].second];\n\t\t\t\tif (ch &amp;lt; earlistC) {\n\t\t\t\t\tearlistC = ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_ans.push_back(earlistC);\n\t\t\tif ((m_viiPos.front().first == (int)(m_rows - 1)) &amp;amp;&amp;amp; (m_viiPos.front().second == (int)(m_cols - 1))) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tFOR(i, numCands) {\n\t\t\t\tif (m_map[m_viiPos[i].first][m_viiPos[i].second] == earlistC) {\n\t\t\t\t\tm_posQ.push(m_viiPos[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_viiPos.clear();\n\t\t}\n\t}\n\nGitHub\n\nNamingDaughter\n\n\n"
} ,
  
  {
    "title"    : "Hiking Trail",
    "category" : "",
    "tags"     : " C++, DFS with backtracking",
    "url"      : "/algoguru/2019/07/16/Hiking-Trail.html",
    "date"     : "July 16, 2019",
    "excerpt"  : "Source\n\n\tvoid _DFS(const ii&amp;amp; pos, const int dist, const bool bDigged) {\n\t\t// Visit!\n\t\tm_map[pos.first][pos.second].first = 1;\n\t\tconst int height = m_map[pos.first][pos.second].second;\n\n\t\tif (dist &amp;gt; m_maxDist)\n\t\t{\n\t\t\tm_maxDist = dist;\n\t\t}\n\n\t...",
  "content"  : "Source\n\n\tvoid _DFS(const ii&amp;amp; pos, const int dist, const bool bDigged) {\n\t\t// Visit!\n\t\tm_map[pos.first][pos.second].first = 1;\n\t\tconst int height = m_map[pos.first][pos.second].second;\n\n\t\tif (dist &amp;gt; m_maxDist)\n\t\t{\n\t\t\tm_maxDist = dist;\n\t\t}\n\n\t\t// Check if it&#39;s a deepest point\n\t\tif (height == m_deepest)\n\t\t{\n\t\t\tif (bDigged == 1) {\n\t\t\t\tm_map[pos.first][pos.second].first = 0; // backtracking!\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ((size_t)dist == m_mapSizeN * m_mapSizeN) {\n\t\t\tm_map[pos.first][pos.second].first = 0; // backtracking!\n\t\t\treturn;\n\t\t}\n\n\t\t// look up 4 dirs\n\t\tFOR(dir, eDIR_LEN) {\n\t\t\tconst ii nextPos(pos.first + DIR[dir][0], pos.second + DIR[dir][1]);\n\t\t\tif (OOR(nextPos.first, 0, (int)m_mapSizeN - 1)) continue;\n\t\t\tif (OOR(nextPos.second, 0, (int)m_mapSizeN - 1)) continue;\n\t\t\tif (m_map[nextPos.first][nextPos.second].first) continue;\n\t\t\tconst int nextH = m_map[nextPos.first][nextPos.second].second;\n\t\t\tif (bDigged == 0) {\n\t\t\t\t// with optional digging\n\t\t\t\tif ((height - (nextH - (int)m_maxDigK)) &amp;lt;= 0) continue;\n\t\t\t\tint digging = height - nextH;\n\t\t\t\tif (digging &amp;lt;= 0) {\n\t\t\t\t\tP_IFNOT((1 - digging) &amp;lt;= (int)m_maxDigK, height);\n\t\t\t\t\tP_IFNOT((1 - digging) &amp;lt;= (int)m_maxDigK, nextH);\n\t\t\t\t\tP_IFNOT((1 - digging) &amp;lt;= (int)m_maxDigK, digging);\n\t\t\t\t\tm_map[nextPos.first][nextPos.second].second = nextH + (digging-1);\n\t\t\t\t\t_DFS(nextPos, dist + 1, 1);\n\t\t\t\t\t// backtracking!\n\t\t\t\t\tm_map[nextPos.first][nextPos.second].second = nextH;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// without digging\n\t\t\t\tif (height - nextH &amp;lt;= 0) continue;\n\t\t\t}\n\t\t\t_DFS(nextPos, dist + 1, bDigged);\n\t\t}\n\n\t\tm_map[pos.first][pos.second].first = 0; // backtracking!\n\t}\n\nGitHub\n\nHikingTrail\n\n\n"
} ,
  
  {
    "title"    : "LED On Off Pattern",
    "category" : "",
    "tags"     : " C++, implementation, difference from model",
    "url"      : "/algoguru/2019/06/22/LED-on-off-pattern.html",
    "date"     : "June 22, 2019",
    "excerpt"  : "Source\n\nvoid FindViolationPatterns(vector&amp;lt;vii&amp;gt; &amp;amp;vviiCandLists)\n{\n\tS[N] = 2;\n\tFOR(even, 2){\n\t\tvi viAB;\n\t\tii iiCand(-1,-1);\n\t\tvii viiCandList;\n\t\tFOR(idx, N){\n\t\t\tconst int i = (idx + even) % 2;\n\t\t\tviAB.push_back(i);\n\t\t\tCollectCand(idx, viAB...",
  "content"  : "Source\n\nvoid FindViolationPatterns(vector&amp;lt;vii&amp;gt; &amp;amp;vviiCandLists)\n{\n\tS[N] = 2;\n\tFOR(even, 2){\n\t\tvi viAB;\n\t\tii iiCand(-1,-1);\n\t\tvii viiCandList;\n\t\tFOR(idx, N){\n\t\t\tconst int i = (idx + even) % 2;\n\t\t\tviAB.push_back(i);\n\t\t\tCollectCand(idx, viAB, iiCand, viiCandList);\n\t\t}\n\t\tviAB.push_back(2);\n\t\tCollectCand(N, viAB, iiCand, viiCandList);\n\n\t\tvviiCandLists.push_back(viiCandList);\n\t}\n}\n\n\nint FindMaxLengthWithFlip(const vector&amp;lt;vii&amp;gt; &amp;amp;vviiCandLists)\n{\n\tint maxLen = 0;\n\tFOR(i, 2){\n\t\tii range(-1,-1);\n\t\tint nextBegin = -1;\n\t\tconst int numLoops = (int)vviiCandLists.at(i).size();\n\t\tFOR(j, numLoops){\n\t\t\tif(j &amp;gt; 0){\n\t\t\t\trange.second = vviiCandLists.at(i).at(j).first;\n\t\t\t\tCheckMaxLenRange(range, maxLen);\n\t\t\t\trange.first = nextBegin;\n\t\t\t}\n\t\t\tnextBegin = vviiCandLists.at(i).at(j).second;\n\t\t}\n\n\t\trange.second = N;\n\t\tCheckMaxLenRange(range, maxLen);\n\t}\n\treturn maxLen;\n}\n\nGitHub\n\nLED_OnOffPattern\n\n\n"
} ,
  
  {
    "title"    : "Permutation Cycles",
    "category" : "",
    "tags"     : " C++, unordered_set, STL",
    "url"      : "/algoguru/2019/06/18/perm-cycles.html",
    "date"     : "June 18, 2019",
    "excerpt"  : "Source\n\n        FOR(i, m_N){\n            usi::iterator it = m_usiPerm.find(i+1);\n            if(it == m_usiPerm.end()){\n                continue;\n            }\n            m_usiPerm.erase(it);\n\n            if (m_viPerm.at(i) == i+1){\n             ...",
  "content"  : "Source\n\n        FOR(i, m_N){\n            usi::iterator it = m_usiPerm.find(i+1);\n            if(it == m_usiPerm.end()){\n                continue;\n            }\n            m_usiPerm.erase(it);\n\n            if (m_viPerm.at(i) == i+1){\n                cycleCnt++;\n            }\n            else{\n                int nodeFrom = i+1;\n                int nodeTo = m_viPerm.at(nodeFrom-1);\n                while(nodeTo != (i+1)){\n                    usi::iterator delit = m_usiPerm.find(nodeTo);\n                    if(W_IFNOT(delit != m_usiPerm.end()));\n                    else {\n                        break;\n                    }\n                    m_usiPerm.erase(delit);\n                    nodeFrom = nodeTo;\n                    nodeTo = m_viPerm.at(nodeFrom-1);\n                    P_IFNOT(nodeTo &amp;lt;= m_N, nodeTo);\n                }\n                cycleCnt++;\n            }\n        }\n\nGitHub\n\nPermCycles\n\n\n"
} ,
  
  {
    "title"    : "String Editor",
    "category" : "",
    "tags"     : " C++, STL, list",
    "url"      : "/algoguru/2019/04/28/string-editor.html",
    "date"     : "April 28, 2019",
    "excerpt"  : "Source\n\nint Left(int pos){\n    if (pos &amp;lt;= 0) return pos;\n    pos--;\n    itPos--;\n    return pos;\n}\n\nint Right(int pos){\n    if (pos &amp;gt;= len) return pos;\n    pos++;\n    itPos++;\n    return pos;\n}\n\nint Del(int pos){\n    if (pos &amp;lt;= 0) return ...",
  "content"  : "Source\n\nint Left(int pos){\n    if (pos &amp;lt;= 0) return pos;\n    pos--;\n    itPos--;\n    return pos;\n}\n\nint Right(int pos){\n    if (pos &amp;gt;= len) return pos;\n    pos++;\n    itPos++;\n    return pos;\n}\n\nint Del(int pos){\n    if (pos &amp;lt;= 0) return pos;\n    lc::iterator it = itPos;\n    lcL.erase(--it);\n    len = (int)lcL.size();\n    return --pos;\n}\n\nint Ins(int pos, char alpha){\n    if (pos &amp;lt; 0) return pos;\n    if (pos &amp;gt; len) return pos;\n    lcL.insert(itPos, alpha);\n    len = (int)lcL.size();\n    return ++pos;\n}\n\nvoid EditStr(const int numCmds){\n    int pos = ParseStr();\n    FOR(i, numCmds){\n        char a = cmd[i];\n        switch(a){\n        case 1:\n            pos = Left(pos);\n            break;\n        case 2:\n            pos = Right(pos);\n            break;\n        case 3:\n            pos = Del(pos);\n            break;\n        default:\n            pos = Ins(pos, a);\n            break;\n        }\n    }\n}\n\nGitHub\n\nStringEditor\n\n\n"
} ,
  
  {
    "title"    : "Connect Pipes",
    "category" : "",
    "tags"     : " C++, DFS, BFS, STL, queue",
    "url"      : "/algoguru/2019/04/25/connect-pipes.html",
    "date"     : "April 25, 2019",
    "excerpt"  : "Source\n\nenum eDir{\n\teD = 0,\n\teR,\n\teU,\n\teL,\n\tNUM_DIRS\n};\nconst int NUM_PIPE_KINDS = 12;\nconst int N_DIR[NUM_DIRS] = {eU, eL, eD, eR};\nconst int DIR[NUM_DIRS][2] = { {1,0},{0,1},{-1,0},{0,-1} };\nconst int CAN_GO[NUM_PIPE_KINDS][NUM_DIRS] = {\n\t{0,0,0...",
  "content"  : "Source\n\nenum eDir{\n\teD = 0,\n\teR,\n\teU,\n\teL,\n\tNUM_DIRS\n};\nconst int NUM_PIPE_KINDS = 12;\nconst int N_DIR[NUM_DIRS] = {eU, eL, eD, eR};\nconst int DIR[NUM_DIRS][2] = { {1,0},{0,1},{-1,0},{0,-1} };\nconst int CAN_GO[NUM_PIPE_KINDS][NUM_DIRS] = {\n\t{0,0,0,0},\n\t{0,1,0,1},\n\t{1,0,1,0},\n\t{1,1,0,0},\n\t{1,0,0,1},\n\t{0,0,1,1},\n\t{0,1,1,0},\n\t{1,1,1,0},\n\t{1,1,0,1},\n\t{1,0,1,1},\n\t{0,1,1,1},\n\t{1,1,1,1},\n};\n\nint visit[MAX_N][MAX_N] = {0,};\nint CheckRangeFlagPipe(const ii nextPos, const int dir){\n\tif (visit[nextPos.first][nextPos.second] != 0) return 0;\n\tif (OOR(nextPos.first, 0, N-1)) return 0;\n\tif (OOR(nextPos.second, 0, N-1)) return 0;\n\tint nextDir = N_DIR[dir];\n\treturn CAN_GO[map[nextPos.first][nextPos.second]][nextDir];\n}\n\nint cnt = 0;\nvoid DFS(const ii pos){\n\tvisit[pos.first][pos.second] = ++cnt;\n\tFOR(dir, NUM_DIRS){\n\t\tif (CAN_GO[map[pos.first][pos.second]][dir] == 0) continue;\n\t\tii nextPos(pos.first+DIR[dir][0], pos.second+DIR[dir][1]);\n\t\tif (CheckRangeFlagPipe(nextPos, dir)){\n\t\t\tDFS(nextPos);\n\t\t}\n\t}\n}\n\nqii iiPosQ;\nvoid BFS(const ii start){\n\tvisit[start.first][start.second] = ++cnt;\n\tiiPosQ.push(start);\n\twhile(!iiPosQ.empty()){\n\t\tii pos = iiPosQ.front(); iiPosQ.pop();\n\t\tFOR(dir, NUM_DIRS){\n\t\t\tif (CAN_GO[map[pos.first][pos.second]][dir] == 0) continue;\n\t\t\tii nextPos(pos.first+DIR[dir][0], pos.second+DIR[dir][1]);\n\t\t\tif (CheckRangeFlagPipe(nextPos, dir)){\n\t\t\t\tvisit[nextPos.first][nextPos.second] = ++cnt;\n\t\t\t\tiiPosQ.push(nextPos);\n\t\t\t}\n\t\t}\n\t}\n}\n\nGitHub\n\nConnectPipes\n\n\n"
} ,
  
  {
    "title"    : "Warehouse",
    "category" : "",
    "tags"     : " C++, Floyd-Warshall",
    "url"      : "/algoguru/2019/04/22/warehouse.html",
    "date"     : "April 22, 2019",
    "excerpt"  : "Source\n\n// Init\nFOR(i, N){\n    FOR(j, N){\n        if (i == j)\n            arDist[i][j] = 0;\n        else\n            arDist[i][j] = INF;\n    }\n}\nFOR(i, M){\n    arDist[A[i]-1][B[i]-1] = D[i];\n    arDist[B[i]-1][A[i]-1] = D[i];\n}\n\n// Update with Flo...",
  "content"  : "Source\n\n// Init\nFOR(i, N){\n    FOR(j, N){\n        if (i == j)\n            arDist[i][j] = 0;\n        else\n            arDist[i][j] = INF;\n    }\n}\nFOR(i, M){\n    arDist[A[i]-1][B[i]-1] = D[i];\n    arDist[B[i]-1][A[i]-1] = D[i];\n}\n\n// Update with Floyd\nFOR(k, N){\n    FOR(i, N){\n        if (arDist[i][k] == INF) continue;\n        FOR(j, N){\n            arDist[i][j] = min(arDist[i][j], arDist[i][k]+arDist[k][j]);\n        }\n    }\n}\n\n// Find min worst\nint minWorst = INF;\nFOR(k, N){\n    int worst = 0;\n    FOR(i, N){\n        if (k==i) continue;\n        int&amp;amp; dist = arDist[k][i];\n        W_IFNOT(dist &amp;gt; 0);\n        if (dist == INF) continue;\n        W_IFNOT(dist &amp;lt; INF);\n        if (dist &amp;gt; worst)\n            worst = dist;\n    }\n    if (worst==0) continue;\n    if (worst &amp;lt; minWorst)\n        minWorst = worst;\n}\nans = minWorst;\n\nGitHub\n\nWarehouse\n\n\n"
} ,
  
  {
    "title"    : "Circle List Order",
    "category" : "",
    "tags"     : " C++, list, STL, advance",
    "url"      : "/algoguru/2019/04/22/circle-list-order.html",
    "date"     : "April 22, 2019",
    "excerpt"  : "Source\n\nint curN = N;\nint curS = S-1;\nconst int constM = M-1;\n\nli numL;\nFOR(i, curN){\n    numL.push_back(i+1);\n}\n\nli::iterator it = numL.begin();\n\nFOR(i, N){\n    int chosen = (curS+constM)%curN;\n    \n    advance(it, chosen);\n    cout &amp;lt;&amp;lt; *it ...",
  "content"  : "Source\n\nint curN = N;\nint curS = S-1;\nconst int constM = M-1;\n\nli numL;\nFOR(i, curN){\n    numL.push_back(i+1);\n}\n\nli::iterator it = numL.begin();\n\nFOR(i, N){\n    int chosen = (curS+constM)%curN;\n    \n    advance(it, chosen);\n    cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &quot; &quot;;\n    numL.erase(it);\n    it = numL.begin();\n    \n    curS = chosen;\n    curN = numL.size();\n}\n\nGitHub\n\nCircleListOrder\n\n\n"
} ,
  
  {
    "title"    : "UnitTest: Drone Go",
    "category" : "",
    "tags"     : " C++, implementation, unittest",
    "url"      : "/algoguru/2019/04/09/unittest-drone-go.html",
    "date"     : "April 9, 2019",
    "excerpt"  : "Source\n\n/**\n * (y, x) 좌표를 표현하는 자료구조\n *\ntypedef struct pos {\n\tint y;\n\tint x;\n} POS;\n\n/**\n * 화재 감지 센서 인터페이스\n *\nclass FireSensor\n{\npublic:\n\t/**\n\t * 현재 화재를 감지한 센서의 위치 값을 반환\n\t * @return POS 타입의 (y, x) 좌표. 예를 들어, 1번 센서에서 화재를 감지한 경우 {1, 10}을 반환\n\t *\n\tvirt...",
  "content"  : "Source\n\n/**\n * (y, x) 좌표를 표현하는 자료구조\n *\ntypedef struct pos {\n\tint y;\n\tint x;\n} POS;\n\n/**\n * 화재 감지 센서 인터페이스\n *\nclass FireSensor\n{\npublic:\n\t/**\n\t * 현재 화재를 감지한 센서의 위치 값을 반환\n\t * @return POS 타입의 (y, x) 좌표. 예를 들어, 1번 센서에서 화재를 감지한 경우 {1, 10}을 반환\n\t *\n\tvirtual POS getSensorPosition() = 0;\n};\n\n/**\n * 드론 관제 시스템 (테스트 대상)\n *\nclass DroneController\n{\n\tPOS currentDrone1_ = { 0,0 };\n\tPOS currentDrone2_ = { 10,10 };\n\t\n\tFireSensor* sensor_;\n\t...\npublic:\n\tDroneController(FireSensor* sensor) : sensor_(sensor) { ... }\n\t\n\t/**\n\t * 화재가 발생한 위치를 얻어와서 현재 드론과의 위치를 계산하여 가장 가까운 드론을 선택하는 함수 (테스트 대상)\n\t * 다음 위치 계산을 위해 선택된 드론의 위치를 저장해둔다. (선택된 드론이 해당 좌표로 이동함을 가정)\n\t * @return 화재가 발생한 곳과 가장 가까운 드론의 번호. 1 혹은 2\n\t *\n\tint selectDrone()\n\t{\n\t\tPOS sensed = sensor_-&amp;gt;getSensorPosition();  // 화제를 감지한 센서의 위치 획득\n\n\t\tint dx = currentDrone1_.x - sensed.x;\n\t\tint dy = currentDrone1_.y - sensed.y;\n\t\tint dist1 = dx*dx + dy*dy;\n\n\t\tdx = currentDrone2_.x - sensed.x;\n\t\tdy = currentDrone2_.y - sensed.y;\n\t\tint dist2 = dx*dx + dy*dy;\n\n\t\tif (dist2 &amp;gt;= dist1)\n\t\t{\n\t\t\tcurrentDrone1_ = sensed;\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurrentDrone2_ = sensed;\n\t\t\treturn 2;\n\t\t}\n\t}\n\t...\n}\n\nmake Stub Class\n\n// 문제 3. 테스트 코드 작성\nclass StubSensor: public FireSensor\n{\npublic:\n\tPOS m_testPos;\t\n\tPOS getSensorPosition(){\n\t\treturn m_testPos;\n\t}\n};\n\nvoid test_3_1()\n{\n\t// TODO: 항목 3-1. \n\t// 화재 위치가 센서 1, 7, 2, 3, 5 순으로 감지되는 상황을 재현하는 테스트 코드\n\tStubSensor sensor;\n\tDroneController dc((FireSensor*)&amp;amp;sensor);\n\tsensor.m_testPos.y = 1; sensor.m_testPos.x = 10;\n\tdc.selectDrone();\n\tsensor.m_testPos.y = 8; sensor.m_testPos.x = 2;\n\tdc.selectDrone();\n\tsensor.m_testPos.y = 2; sensor.m_testPos.x = 6;\n\tdc.selectDrone();\n\tsensor.m_testPos.y = 4; sensor.m_testPos.x = 1;\n\tdc.selectDrone();\n\tsensor.m_testPos.y = 6; sensor.m_testPos.x = 10;\n\tdc.selectDrone();\n}\n\nGitHub (n/a)\n\n\n"
} ,
  
  {
    "title"    : "Mario game",
    "category" : "",
    "tags"     : " C++, implementation, logic",
    "url"      : "/algoguru/2019/04/08/mario-game.html",
    "date"     : "April 8, 2019",
    "excerpt"  : "Source\n\nconst int FindMaxH(const int N, const int (&amp;amp;P)[MAX_N])\n{\n\tint h = 0;\n\tint ud = 1;\t\n\tfor (int i=0; i&amp;lt;N; i++){\n\t\tif(ud == 1){\n\t\t\tif(P[i] &amp;gt; P[i+1]){\n\t\t\t\t// go down\n\t\t\t\th += P[i];\n\t\t\t\tud = -1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(P[i] &amp;lt; P[i+1])...",
  "content"  : "Source\n\nconst int FindMaxH(const int N, const int (&amp;amp;P)[MAX_N])\n{\n\tint h = 0;\n\tint ud = 1;\t\n\tfor (int i=0; i&amp;lt;N; i++){\n\t\tif(ud == 1){\n\t\t\tif(P[i] &amp;gt; P[i+1]){\n\t\t\t\t// go down\n\t\t\t\th += P[i];\n\t\t\t\tud = -1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(P[i] &amp;lt; P[i+1]){\n\t\t\t\t// go up\n\t\t\t\th -= P[i];\n\t\t\t\tud = 1;\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\treturn h;\n}\n\nGitHub\n\nMarioGame\n\n\n"
} 
  
  
  
]
